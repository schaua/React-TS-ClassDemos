To create a RESTful Web API in C# that provides CRUD operations for managing Scientist data, we will use ASP.NET Core and Entity Framework Core. The architecture will be divided into several parts: Models, Data Access Layer (DAL), Controllers, and Startup configuration.

Let's start with the model class for Scientist:

Models/Scientist.cs
```csharp
using System;
using System.ComponentModel.DataAnnotations;

namespace ScientistAPI.Models
{
    public class Scientist
    {
        [Key]
        public int Id { get; set; }

        [Required]
        public string Name { get; set; }

        public string ImageId { get; set; }

        [Required]
        public string Field { get; set; }

        [Required]
        public DateTime BirthDate { get; set; }

        public DateTime? DeathDate { get; set; }

        [Required]
        public string CountryOfOrigin { get; set; }
    }
}
```

Next, we'll create a DbContext class for Entity Framework:

Data/ScientistContext.cs
```csharp
using Microsoft.EntityFrameworkCore;
using ScientistAPI.Models;

namespace ScientistAPI.Data
{
    public class ScientistContext : DbContext
    {
        public ScientistContext(DbContextOptions<ScientistContext> options) : base(options)
        {
        }

        public DbSet<Scientist> Scientists { get; set; }
    }
}
```

Now, let's create the ScientistController which will handle the CRUD operations:

Controllers/ScientistController.cs
```csharp
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using ScientistAPI.Data;
using ScientistAPI.Models;

namespace ScientistAPI.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ScientistController : ControllerBase
    {
        private readonly ScientistContext _context;

        public ScientistController(ScientistContext context)
        {
            _context = context;
        }

        // GET: api/Scientist
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Scientist>>> GetScientists()
        {
            return await _context.Scientists.ToListAsync();
        }

        // GET: api/Scientist/5
        [HttpGet("{id}")]
        public async Task<ActionResult<Scientist>> GetScientist(int id)
        {
            var scientist = await _context.Scientists.FindAsync(id);

            if (scientist == null)
            {
                return NotFound();
            }

            return scientist;
        }

        // PUT: api/Scientist/5
        [HttpPut("{id}")]
        public async Task<IActionResult> PutScientist(int id, Scientist scientist)
        {
            if (id != scientist.Id)
            {
                return BadRequest();
            }

            _context.Entry(scientist).State = EntityState.Modified;

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!ScientistExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return NoContent();
        }

        // POST: api/Scientist
        [HttpPost]
        public async Task<ActionResult<Scientist>> PostScientist(Scientist scientist)
        {
            _context.Scientists.Add(scientist);
            await _context.SaveChangesAsync();

            return CreatedAtAction("GetScientist", new { id = scientist.Id }, scientist);
        }

        // DELETE: api/Scientist/5
        [HttpDelete("{id}")]
        public async Task<ActionResult<Scientist>> DeleteScientist(int id)
        {
            var scientist = await _context.Scientists.FindAsync(id);
            if (scientist == null)
            {
                return NotFound();
            }

            _context.Scientists.Remove(scientist);
            await _context.SaveChangesAsync();

            return scientist;
        }

        private bool ScientistExists(int id)
        {
            return _context.Scientists.Any(e => e.Id == id);
        }
    }
}
```

Finally, we need to configure our application to use PostgreSQL and enable CORS in the Startup.cs file:

Startup.cs
```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.EntityFrameworkCore;
using ScientistAPI.Data;

namespace ScientistAPI
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        public void ConfigureServices(IServiceCollection services)
        {
            services.AddDbContext<ScientistContext>(options =>
                options.UseNpgsql(Configuration.GetConnectionString("DefaultConnection")));

            services.AddControllers();

            services.AddCors(options =>
            {
                options.AddPolicy("AllowAllOrigins",
                    builder =>
                    {
                        builder.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader();
                    });
            });
        }

        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseHttpsRedirection();

            app.UseRouting();

            app.UseAuthorization();

            app.UseCors("AllowAllOrigins");

            app.UseEndpoints(endpoints =>
            {
                endpoints.MapControllers();
            });
        }
    }
}
```

In the appsettings.json file, you need to specify the connection string to your PostgreSQL database:

appsettings.json
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=my_host;Database=my_db;Username=my_user;Password=my_pw"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
```

This concludes a fully working implementation.